/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 CodeScreens.glb -k -t 
*/
import ShikiHighlighter from "react-shiki";
import "./scroll.css";

const testCode = `const gl = canvas.getContext("webgl2");
if (!gl) {
  console.error("WebGL 2 not available");
  return;
}

gl.clearColor(0, 0, 0, 1);

// Vertex shader
const vsSource = \`#version 300 es
layout (location=0) in vec4 position;
layout (location=1) in vec3 color;
out vec3 vColor;
void main() {
    vColor = color;
    gl_Position = position;
}\`;

// Fragment shader
const fsSource = \`#version 300 es
precision highp float;
in vec3 vColor;
out vec4 fragColor;
void main() {
    fragColor = vec4(vColor, 1.0);
}\`;

const createShader = (type, source) => {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
};

const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error(gl.getProgramInfoLog(program));
}
gl.useProgram(program);

// Geometry
const triangleArray = gl.createVertexArray();
gl.bindVertexArray(triangleArray);

const positions = new Float32Array([
  -0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.0, 0.5, 0.0,
]);
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(0);

const colors = new Float32Array([
  1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
]);
const colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(1);

// Draw
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.TRIANGLES, 0, 3);
    `;
import * as THREE from "three";
import React, { useRef, useEffect } from "react";
import { useGLTF, Html } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";
import { useAtom } from "jotai";
import { codeScreenActive } from "../atoms/atoms";
import gsap from "gsap";
import { degToRad } from "three/src/math/MathUtils.js";
import Triangle from "../components/triangle";

type GLTFResult = GLTF & {
  nodes: {
    Cylinder: THREE.Mesh;
    Plane: THREE.Mesh;
    Plane001: THREE.Mesh;
  };
  materials: {};
  animations: GLTFAction[];
};

const CodeScreens = (props: JSX.IntrinsicElements["group"]) => {
  const { nodes, materials } = useGLTF("/CodeScreens.glb") as GLTFResult;
  const groupRef = useRef<THREE.Group>(null);
  const [active, setActive] = useAtom(codeScreenActive);

  useEffect(() => {
    if (!groupRef.current) return;
    if (active == false) {
      gsap.to(groupRef.current.rotation, {
        x: degToRad(0), // 0 degrees in radians
        duration: 1, // 1 second
        ease: "power2.inOut",
      });
    }
    if (active == true) {
      gsap.to(groupRef.current.rotation, {
        x: degToRad(180), // 180 degrees in radians
        duration: 1, // 1 second
        ease: "power2.inOut",
      });
    }
  }, [active]);

  return (
    <group ref={groupRef} {...props} dispose={null}>
      <mesh
        name="Cylinder"
        geometry={nodes.Cylinder.geometry}
        material={nodes.Cylinder.material}
        rotation={[-Math.PI, 0, 0]}
        scale={[0.053, 1, 0.053]}
        onClick={() => setActive((prev) => !prev)}
      >
        <mesh
          name="Plane"
          geometry={nodes.Plane.geometry}
          material={nodes.Plane.material}
          position={[18.733, -1.97, -1.819]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={[15.762, 15.762, 0.841]}
        >
          <Html
            style={{
              userSelect: "none",
              margin: "0",
              padding: "0",
              width: "1080px",
              height: "1080px",
              backgroundColor: "rgb(11, 14, 20)",
            }}
            castShadow
            receiveShadow
            occlude="blending"
            transform
            scale={0.13}
            distanceFactor={5}
            position={[-0.05, 0.1, 0]}
            rotation={[degToRad(90), degToRad(180), 0]}
          >
            {/* {<Triangle></Triangle>} */}
            <ShikiHighlighter
              style={{
                fontSize: "1.4rem",
                width: "100%",
                height: "100%",
                display: "grid",
                margin: "0",
                padding: "0",
              }}
              langStyle={{ fontSize: "1.2rem" }}
              language="jsx"
              theme="ayu-dark"
            >
              {testCode.trim()}
            </ShikiHighlighter>
          </Html>
        </mesh>

        <mesh
          name="Plane001"
          geometry={nodes.Plane001.geometry}
          material={nodes.Plane001.material}
          position={[-18.733, -1.97, -1.819]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={[15.762, 15.762, 0.841]}
        >
          <Html
            style={{ userSelect: "none", width: "1080px", height: "1080px" }}
            castShadow
            receiveShadow
            occlude="blending"
            transform
            scale={0.13}
            distanceFactor={5}
            position={[0.05, 0.1, 0]}
            rotation={[degToRad(90), degToRad(180), 0]}
          >
            {<Triangle></Triangle>}
          </Html>
        </mesh>
      </mesh>
    </group>
  );
};

useGLTF.preload("/CodeScreens.glb");
export default CodeScreens;
